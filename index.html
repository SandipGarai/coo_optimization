<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canine Olfactory Optimizer (COO)</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #333;
        overflow-x: hidden;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      header {
        text-align: center;
        padding: 60px 20px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        margin-bottom: 30px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      h1 {
        font-size: 3em;
        color: #667eea;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
      }

      .subtitle {
        font-size: 1.3em;
        color: #666;
        margin-bottom: 20px;
      }

      .tagline {
        font-size: 1.1em;
        color: #888;
        font-style: italic;
      }

      .section {
        background: white;
        border-radius: 15px;
        padding: 40px;
        margin-bottom: 30px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      }

      h2 {
        color: #667eea;
        font-size: 2.2em;
        margin-bottom: 20px;
        border-bottom: 3px solid #667eea;
        padding-bottom: 10px;
      }

      h3 {
        color: #764ba2;
        font-size: 1.5em;
        margin-top: 25px;
        margin-bottom: 15px;
      }

      canvas {
        border: 2px solid #667eea;
        border-radius: 10px;
        display: block;
        margin: 20px auto;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        background: #f9f9f9;
      }

      .controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin: 30px 0;
      }

      .control-group {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 10px;
        border-left: 4px solid #667eea;
      }

      label {
        display: block;
        font-weight: 600;
        color: #555;
        margin-bottom: 8px;
        font-size: 0.95em;
      }

      input[type="range"] {
        width: 100%;
        margin: 10px 0;
        height: 6px;
        border-radius: 5px;
        background: #ddd;
        outline: none;
      }

      input[type="range"]::-webkit-slider-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #667eea;
        cursor: pointer;
      }

      input[type="number"] {
        width: 100%;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 5px;
        font-size: 1em;
      }

      .value-display {
        display: inline-block;
        background: #667eea;
        color: white;
        padding: 5px 12px;
        border-radius: 5px;
        font-weight: bold;
        margin-left: 10px;
      }

      button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 15px 30px;
        font-size: 1.1em;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        font-weight: 600;
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
      }

      button:active {
        transform: translateY(0);
      }

      .button-group {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        margin: 20px 0;
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin: 20px 0;
      }

      .stat-box {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      .stat-label {
        font-size: 0.9em;
        opacity: 0.9;
        margin-bottom: 5px;
      }

      .stat-value {
        font-size: 1.8em;
        font-weight: bold;
      }

      .legend {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
        margin: 20px 0;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        border: 2px solid #333;
      }

      .description {
        line-height: 1.8;
        color: #555;
        margin: 15px 0;
        font-size: 1.05em;
      }

      .highlight {
        background: #fff3cd;
        padding: 20px;
        border-left: 4px solid #ffc107;
        border-radius: 5px;
        margin: 20px 0;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      .pulse {
        animation: pulse 2s infinite;
      }

      .tab-container {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        border-bottom: 2px solid #ddd;
      }

      .tab {
        padding: 12px 24px;
        background: #f8f9fa;
        border: none;
        border-radius: 8px 8px 0 0;
        cursor: pointer;
        font-size: 1em;
        transition: all 0.3s ease;
      }

      .tab.active {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>üêï Canine Olfactory Optimizer (COO)</h1>
        <div class="subtitle">A Novel Bio-Inspired Metaheuristic Algorithm</div>
        <div class="tagline">
          Inspired by how dogs track scents to find food
        </div>
      </header>

      <!-- Section 1: Biological Inspiration -->
      <div class="section">
        <h2>üéØ Biological Inspiration: How Dogs Find Food</h2>
        <p class="description">
          Watch how a pack of dogs uses their incredible sense of smell to
          locate food. Dogs employ multiple strategies: following scent
          gradients, casting about in zigzag patterns when they lose the trail,
          and cooperating with their pack to cover more ground.
        </p>

        <canvas id="bioCanvas" width="900" height="600"></canvas>

        <!-- <div class="legend">
          <div class="legend-item">
            <div class="legend-color" style="background: #3498db"></div>
            <span>Dogs (Searching)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #e74c3c"></div>
            <span>Food Target</span>
          </div>
          <div class="legend-item">
            <div
              class="legend-color"
              style="background: rgba(46, 204, 113, 0.3)"
            ></div>
            <span>Scent Gradient (Stronger = Darker)</span>
          </div>
        </div> -->

        <div class="legend">
          <div class="legend-item">
            <div
              class="legend-color"
              style="background: white; border-color: #297fb900"
            >
              <span style="font-size: 16px; display: block; text-align: center"
                >üê∂</span
              >
            </div>
            <span>Dogs (Searching)</span>
          </div>

          <div class="legend-item">
            <div
              class="legend-color"
              style="background: white; border-color: #27ae5f00"
            >
              <span style="font-size: 16px; display: block; text-align: center"
                >ü¶¥</span
              >
            </div>
            <span>Dogs (Found Target)</span>
          </div>

          <div class="legend-item">
            <div
              class="legend-color"
              style="
                background: #e74c3c;
                border-color: #c0392b;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 14px;
              "
            >
              üçñ
            </div>
            <span>Food Target</span>
          </div>

          <div class="legend-item">
            <div
              class="legend-color"
              style="
                background: rgba(46, 204, 113, 0.3);
                border-color: rgba(46, 204, 113, 0.5);
              "
            ></div>
            <span>Scent Gradient (Stronger = Darker)</span>
          </div>
        </div>

        <div class="button-group">
          <button onclick="startBioSimulation()">‚ñ∂ Start Simulation</button>
          <button onclick="resetBioSimulation()">üîÑ Reset</button>
        </div>

        <div class="stats">
          <div class="stat-box">
            <div class="stat-label">Dogs Searching</div>
            <div class="stat-value" id="bioDogsCount">8</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Average Distance</div>
            <div class="stat-value" id="bioAvgDist">0</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Dogs Found Food</div>
            <div class="stat-value" id="bioFoundCount">0</div>
          </div>
        </div>
      </div>

      <!-- Section 2: Algorithm Visualization -->
      <div class="section">
        <h2>‚öôÔ∏è COO Algorithm: Interactive Hyperparameter Control</h2>
        <p class="description">
          Explore how different hyperparameters control the behavior of the
          optimization algorithm. Adjust pack sizes, movement parameters, and
          cooperation strategies to see their effects in real-time.
        </p>

        <div class="tab-container">
          <button class="tab active" onclick="switchTab('basic')">
            Basic Parameters
          </button>
          <button class="tab" onclick="switchTab('advanced')">
            Advanced Parameters
          </button>
        </div>

        <div id="basic" class="tab-content active">
          <div class="controls">
            <div class="control-group">
              <label
                >Number of Packs
                <span class="value-display" id="nPacksVal">2</span></label
              >
              <input
                type="range"
                id="nPacks"
                min="1"
                max="5"
                value="2"
                oninput="updateAlgoParams()"
              />
              <small
                >Multiple packs explore different regions simultaneously</small
              >
            </div>
            <div class="control-group">
              <label
                >Pack Size
                <span class="value-display" id="packSizeVal">8</span></label
              >
              <input
                type="range"
                id="packSize"
                min="3"
                max="20"
                value="8"
                oninput="updateAlgoParams()"
              />
              <small>Number of dogs (agents) in each pack</small>
            </div>
            <div class="control-group">
              <label
                >Momentum (œâ)
                <span class="value-display" id="momentumVal">0.6</span></label
              >
              <input
                type="range"
                id="momentum"
                min="0"
                max="1"
                step="0.1"
                value="0.6"
                oninput="updateAlgoParams()"
              />
              <small
                >Inertia - how much dogs maintain their current direction</small
              >
            </div>
            <div class="control-group">
              <label
                >Local Attraction (Œ±)
                <span class="value-display" id="localAttrVal">0.3</span></label
              >
              <input
                type="range"
                id="localAttr"
                min="0"
                max="1"
                step="0.1"
                value="0.3"
                oninput="updateAlgoParams()"
              />
              <small>Attraction to pack-local best position</small>
            </div>
            <div class="control-group">
              <label
                >Cooperation Weight
                <span class="value-display" id="coopWeightVal">0.5</span></label
              >
              <input
                type="range"
                id="coopWeight"
                min="0"
                max="1"
                step="0.1"
                value="0.5"
                oninput="updateAlgoParams()"
              />
              <small
                >Attraction to global best position (increases over time)</small
              >
            </div>
            <div class="control-group">
              <label
                >Exploration Radius (œÉ‚ÇÅ)
                <span class="value-display" id="sigma1Val">0.35</span></label
              >
              <input
                type="range"
                id="sigma1"
                min="0"
                max="1"
                step="0.05"
                value="0.35"
                oninput="updateAlgoParams()"
              />
              <small>Sniffing noise - random local exploration</small>
            </div>
          </div>
        </div>

        <div id="advanced" class="tab-content">
          <div class="controls">
            <div class="control-group">
              <label
                >Zigzag Probability
                <span class="value-display" id="zigzagProbVal"
                  >0.18</span
                ></label
              >
              <input
                type="range"
                id="zigzagProb"
                min="0"
                max="0.5"
                step="0.02"
                value="0.18"
                oninput="updateAlgoParams()"
              />
              <small>Casting behavior when dogs lose the trail</small>
            </div>
            <div class="control-group">
              <label
                >Zigzag Amplitude (œÉ‚ÇÇ)
                <span class="value-display" id="sigma2Val">0.12</span></label
              >
              <input
                type="range"
                id="sigma2"
                min="0"
                max="0.5"
                step="0.02"
                value="0.12"
                oninput="updateAlgoParams()"
              />
              <small>Magnitude of reacquisition movements</small>
            </div>
            <div class="control-group">
              <label
                >Elitist Exchange Freq
                <span class="value-display" id="eliteFreqVal">6</span></label
              >
              <input
                type="range"
                id="eliteFreq"
                min="1"
                max="20"
                value="6"
                oninput="updateAlgoParams()"
              />
              <small>How often elite dogs are shared between packs</small>
            </div>
            <div class="control-group">
              <label
                >Gradient Refinement %
                <span class="value-display" id="gradPctVal">10</span></label
              >
              <input
                type="range"
                id="gradPct"
                min="0"
                max="50"
                value="10"
                oninput="updateAlgoParams()"
              />
              <small>Percentage of top dogs using gradient-based search</small>
            </div>
            <div class="control-group">
              <label>Use Gradient Refinement</label>
              <input
                type="checkbox"
                id="useGradient"
                checked
                onchange="updateAlgoParams()"
                style="width: auto; height: 20px"
              />
              <small>Enable local gradient-based optimization</small>
            </div>
            <div class="control-group">
              <label>Use Elitist Exchange</label>
              <input
                type="checkbox"
                id="useElitist"
                checked
                onchange="updateAlgoParams()"
                style="width: auto; height: 20px"
              />
              <small>Enable information sharing between packs</small>
            </div>
          </div>
        </div>

        <canvas id="algoCanvas" width="900" height="600"></canvas>

        <div class="button-group">
          <button onclick="startAlgoSimulation()">‚ñ∂ Run Optimization</button>
          <button onclick="resetAlgoSimulation()">üîÑ Reset</button>
          <button onclick="randomizeHyperparameters()">
            üé≤ Random Hyperparameters
          </button>
          <button onclick="findBestHyperparameters()">
            üîç Find Best Hyperparameters
          </button>
        </div>

        <div class="stats">
          <div class="stat-box">
            <div class="stat-label">Iteration</div>
            <div class="stat-value" id="algoIteration">0</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Best Fitness</div>
            <div class="stat-value" id="algoBestFitness">0.00</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Evaluations</div>
            <div class="stat-value" id="algoEvals">0</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Convergence Rate</div>
            <div class="stat-value" id="algoConvergence">0%</div>
          </div>
        </div>
      </div>

      <!-- Section 3: Rosenbrock Function -->
      <div class="section">
        <h2>üèîÔ∏è Rosenbrock Function Optimization</h2>
        <p class="description">
          The Rosenbrock function is a famous test case for optimization
          algorithms, featuring a long, narrow, parabolic valley. The global
          minimum is at (1, 1) with f(x) = 0. Watch how COO navigates this
          challenging landscape!
        </p>

        <div class="highlight">
          <strong>Rosenbrock Function:</strong> f(x, y) = (1 - x)¬≤ + 100(y -
          x¬≤)¬≤ <br /><strong>Global Minimum:</strong> (x, y) = (1, 1), f(1, 1) =
          0
        </div>

        <canvas id="rosenCanvas" width="900" height="600"></canvas>

        <div class="controls">
          <div class="control-group">
            <label
              >View Angle
              <span class="value-display" id="viewAngleVal">45¬∞</span></label
            >
            <input
              type="range"
              id="viewAngle"
              min="0"
              max="360"
              value="45"
              oninput="updateRosenView()"
            />
          </div>
          <div class="control-group">
            <label
              >View Elevation
              <span class="value-display" id="viewElevVal">30¬∞</span></label
            >
            <input
              type="range"
              id="viewElev"
              min="10"
              max="80"
              value="30"
              oninput="updateRosenView()"
            />
          </div>
          <div class="control-group">
            <label
              >Max Iterations
              <span class="value-display" id="maxIterVal">50</span></label
            >
            <input
              type="range"
              id="maxIter"
              min="10"
              max="200"
              value="50"
              oninput="updateRosenParams()"
            />
          </div>
        </div>

        <div class="button-group">
          <button onclick="startRosenOptimization()">
            ‚ñ∂ Start Optimization
          </button>
          <button onclick="resetRosenOptimization()">üîÑ Reset</button>
          <button onclick="randomizeRosenHyperparameters()">
            üé≤ Random Hyperparameters
          </button>
          <button onclick="findBestRosenHyperparameters()">
            üîç Auto-Tune Hyperparameters
          </button>
        </div>

        <div class="stats">
          <div class="stat-box">
            <div class="stat-label">Best Position</div>
            <div class="stat-value" id="rosenBestPos">(0, 0)</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Best Value</div>
            <div class="stat-value" id="rosenBestVal">‚àû</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Distance to Optimum</div>
            <div class="stat-value" id="rosenDistance">-</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Success Rate</div>
            <div class="stat-value" id="rosenSuccess">-</div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ============================================
      // SECTION 1: BIOLOGICAL INSPIRATION SIMULATION
      // ============================================

      const bioCanvas = document.getElementById("bioCanvas");
      const bioCtx = bioCanvas.getContext("2d");
      let bioAnimationId = null;
      let bioDogs = [];
      let foodPos = { x: 750, y: 300 };

      function initBioDogs() {
        bioDogs = [];
        for (let i = 0; i < 8; i++) {
          bioDogs.push({
            x: 150,
            y: 300 + (Math.random() - 0.5) * 100,
            vx: Math.random() * 2 - 1,
            vy: Math.random() * 2 - 1,
            found: false,
          });
        }
      }

      function drawScentGradient() {
        const gradient = bioCtx.createRadialGradient(
          foodPos.x,
          foodPos.y,
          0,
          foodPos.x,
          foodPos.y,
          300
        );
        gradient.addColorStop(0, "rgba(46, 204, 113, 0.4)");
        gradient.addColorStop(0.5, "rgba(46, 204, 113, 0.2)");
        gradient.addColorStop(1, "rgba(46, 204, 113, 0)");
        bioCtx.fillStyle = gradient;
        bioCtx.fillRect(0, 0, bioCanvas.width, bioCanvas.height);
      }

      function drawFood() {
        bioCtx.fillStyle = "#e74c3c";
        bioCtx.beginPath();
        bioCtx.arc(foodPos.x, foodPos.y, 20, 0, Math.PI * 2);
        bioCtx.fill();
        bioCtx.strokeStyle = "#c0392b";
        bioCtx.lineWidth = 3;
        bioCtx.stroke();

        bioCtx.fillStyle = "white";
        bioCtx.font = "bold 16px Arial";
        bioCtx.textAlign = "center";
        bioCtx.fillText("üçñ", foodPos.x, foodPos.y + 6);
      }

      function updateBioDogs() {
        let foundCount = 0;
        let totalDist = 0;

        bioDogs.forEach((dog) => {
          if (dog.found) {
            foundCount++;
            return;
          }

          const dx = foodPos.x - dog.x;
          const dy = foodPos.y - dog.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          totalDist += dist;

          if (dist < 25) {
            dog.found = true;
            foundCount++;
            return;
          }

          // Scent gradient following
          const scent = 1 / (1 + dist / 100);
          dog.vx += (dx / dist) * scent * 0.5;
          dog.vy += (dy / dist) * scent * 0.5;

          // Random sniffing
          dog.vx += (Math.random() - 0.5) * 0.3;
          dog.vy += (Math.random() - 0.5) * 0.3;

          // Zigzag casting
          if (Math.random() < 0.1) {
            dog.vx += (Math.random() - 0.5) * 2;
            dog.vy += (Math.random() - 0.5) * 2;
          }

          // Damping
          dog.vx *= 0.95;
          dog.vy *= 0.95;

          // Update position
          dog.x += dog.vx;
          dog.y += dog.vy;

          // Boundaries
          dog.x = Math.max(20, Math.min(bioCanvas.width - 20, dog.x));
          dog.y = Math.max(20, Math.min(bioCanvas.height - 20, dog.y));
        });

        document.getElementById("bioFoundCount").textContent = foundCount;
        document.getElementById("bioAvgDist").textContent = Math.round(
          totalDist / bioDogs.length
        );
      }

      function drawBioDogs() {
        bioDogs.forEach((dog) => {
          // Choose emoji based on found state
          const emoji = dog.found ? "ü¶¥" : "üê∂";

          // Draw emoji instead of circle
          bioCtx.font = "20px Arial";
          bioCtx.textAlign = "center";
          bioCtx.textBaseline = "middle";
          bioCtx.fillText(emoji, dog.x, dog.y);

          // Optional: small direction indicator if not found
          if (!dog.found) {
            bioCtx.strokeStyle = "#2980b9";
            bioCtx.lineWidth = 2;
            bioCtx.beginPath();
            bioCtx.moveTo(dog.x, dog.y);
            bioCtx.lineTo(dog.x + dog.vx * 5, dog.y + dog.vy * 5);
            bioCtx.stroke();
          }
        });
      }

      function bioAnimationLoop() {
        bioCtx.fillStyle = "#f9f9f9";
        bioCtx.fillRect(0, 0, bioCanvas.width, bioCanvas.height);

        drawScentGradient();
        drawFood();
        updateBioDogs();
        drawBioDogs();

        if (bioDogs.every((d) => d.found)) {
          setTimeout(() => {
            resetBioSimulation();
            startBioSimulation();
          }, 2000);
        } else {
          bioAnimationId = requestAnimationFrame(bioAnimationLoop);
        }
      }

      function startBioSimulation() {
        if (bioAnimationId) cancelAnimationFrame(bioAnimationId);
        if (bioDogs.length === 0) initBioDogs();
        bioAnimationLoop();
      }

      function resetBioSimulation() {
        if (bioAnimationId) cancelAnimationFrame(bioAnimationId);
        initBioDogs();
        bioCtx.fillStyle = "#f9f9f9";
        bioCtx.fillRect(0, 0, bioCanvas.width, bioCanvas.height);
        drawScentGradient();
        drawFood();
        drawBioDogs();
        document.getElementById("bioFoundCount").textContent = "0";
        document.getElementById("bioAvgDist").textContent = "0";
      }

      // ============================================
      // SECTION 2: ALGORITHM VISUALIZATION
      // ============================================

      const algoCanvas = document.getElementById("algoCanvas");
      const algoCtx = algoCanvas.getContext("2d");
      let algoAnimationId = null;
      let algoPacks = [];
      let algoTarget = { x: 750, y: 300 };
      let algoIteration = 0;
      let algoBestPos = null;
      let algoBestFitness = -Infinity;
      let algoParams = {
        nPacks: 2,
        packSize: 8,
        momentum: 0.6,
        localAttr: 0.3,
        coopWeight: 0.5,
        sigma1: 0.35,
        sigma2: 0.12,
        zigzagProb: 0.18,
        eliteFreq: 6,
        gradPct: 10,
        useGradient: true,
        useElitist: true,
        maxIter: 50,
      };

      function switchTab(tabName) {
        document
          .querySelectorAll(".tab")
          .forEach((t) => t.classList.remove("active"));
        document
          .querySelectorAll(".tab-content")
          .forEach((c) => c.classList.remove("active"));
        event.target.classList.add("active");
        document.getElementById(tabName).classList.add("active");
      }

      function updateAlgoParams() {
        algoParams.nPacks = parseInt(document.getElementById("nPacks").value);
        algoParams.packSize = parseInt(
          document.getElementById("packSize").value
        );
        algoParams.momentum = parseFloat(
          document.getElementById("momentum").value
        );
        algoParams.localAttr = parseFloat(
          document.getElementById("localAttr").value
        );
        algoParams.coopWeight = parseFloat(
          document.getElementById("coopWeight").value
        );
        algoParams.sigma1 = parseFloat(document.getElementById("sigma1").value);
        algoParams.sigma2 = parseFloat(document.getElementById("sigma2").value);
        algoParams.zigzagProb = parseFloat(
          document.getElementById("zigzagProb").value
        );
        algoParams.eliteFreq = parseInt(
          document.getElementById("eliteFreq").value
        );
        algoParams.gradPct = parseInt(document.getElementById("gradPct").value);
        algoParams.useGradient = document.getElementById("useGradient").checked;
        algoParams.useElitist = document.getElementById("useElitist").checked;

        document.getElementById("nPacksVal").textContent = algoParams.nPacks;
        document.getElementById("packSizeVal").textContent =
          algoParams.packSize;
        document.getElementById("momentumVal").textContent =
          algoParams.momentum.toFixed(1);
        document.getElementById("localAttrVal").textContent =
          algoParams.localAttr.toFixed(1);
        document.getElementById("coopWeightVal").textContent =
          algoParams.coopWeight.toFixed(1);
        document.getElementById("sigma1Val").textContent =
          algoParams.sigma1.toFixed(2);
        document.getElementById("sigma2Val").textContent =
          algoParams.sigma2.toFixed(2);
        document.getElementById("zigzagProbVal").textContent =
          algoParams.zigzagProb.toFixed(2);
        document.getElementById("eliteFreqVal").textContent =
          algoParams.eliteFreq;
        document.getElementById("gradPctVal").textContent = algoParams.gradPct;
      }

      function objectiveFunction(x, y) {
        const dx = x - algoTarget.x;
        const dy = y - algoTarget.y;
        return -Math.sqrt(dx * dx + dy * dy);
      }
      //   const packDogImages = [];
      //   const dogImageSources = [
      //     "images/dog1.png",
      //     "images/dog2.png",
      //     "images/dog3.png",
      //     "images/dog4.png",
      //     "images/dog5.png",
      //   ];

      //   // Preload images
      //   dogImageSources.forEach((src) => {
      //     const img = new Image();
      //     img.src = src;
      //     packDogImages.push(img);
      //   });

      function initAlgoPacks() {
        algoPacks = [];
        for (let i = 0; i < algoParams.nPacks; i++) {
          const pack = { dogs: [] };
          for (let j = 0; j < algoParams.packSize; j++) {
            pack.dogs.push({
              x: 100 + Math.random() * 150,
              y: 100 + Math.random() * 400,
              vx: 0,
              vy: 0,
            });
          }
          algoPacks.push(pack);
        }
        algoIteration = 0;
        algoBestPos = null;
        algoBestFitness = -Infinity;
      }

      function updateAlgoPacks() {
        algoIteration++;
        const sigma1 = algoParams.sigma1 * Math.exp(-0.05 * algoIteration);
        const sigma2 = algoParams.sigma2 * Math.exp(-0.07 * algoIteration);
        const coopWeight =
          algoParams.coopWeight * (algoIteration / algoParams.maxIter);

        let totalEvals = 0;
        let packBests = [];

        algoPacks.forEach((pack, packIdx) => {
          let packBestFitness = -Infinity;
          let packBestPos = null;

          pack.dogs.forEach((dog) => {
            const fitness = objectiveFunction(dog.x, dog.y);
            totalEvals++;

            if (fitness > packBestFitness) {
              packBestFitness = fitness;
              packBestPos = { x: dog.x, y: dog.y };
            }

            if (fitness > algoBestFitness) {
              algoBestFitness = fitness;
              algoBestPos = { x: dog.x, y: dog.y };
            }
          });

          packBests.push(packBestPos);

          pack.dogs.forEach((dog) => {
            const dx_local = packBestPos.x - dog.x;
            const dy_local = packBestPos.y - dog.y;

            const dx_global = algoBestPos ? algoBestPos.x - dog.x : 0;
            const dy_global = algoBestPos ? algoBestPos.y - dog.y : 0;

            dog.vx =
              algoParams.momentum * dog.vx +
              algoParams.localAttr * dx_local +
              coopWeight * dx_global;
            dog.vy =
              algoParams.momentum * dog.vy +
              algoParams.localAttr * dy_local +
              coopWeight * dy_global;

            dog.x += dog.vx + sigma1 * (Math.random() - 0.5) * 20;
            dog.y += dog.vy + sigma1 * (Math.random() - 0.5) * 20;

            if (Math.random() < algoParams.zigzagProb) {
              dog.x +=
                sigma2 *
                (Math.random() - 0.5) *
                30 *
                Math.sin((2 * Math.PI * algoIteration) / algoParams.maxIter);
              dog.y +=
                sigma2 *
                (Math.random() - 0.5) *
                30 *
                Math.sin((2 * Math.PI * algoIteration) / algoParams.maxIter);
            }

            dog.x = Math.max(20, Math.min(algoCanvas.width - 20, dog.x));
            dog.y = Math.max(20, Math.min(algoCanvas.height - 20, dog.y));
          });
        });

        // Elitist exchange
        if (
          algoParams.useElitist &&
          algoIteration % algoParams.eliteFreq === 0 &&
          packBests.length > 1
        ) {
          algoPacks.forEach((pack) => {
            const randomElite =
              packBests[Math.floor(Math.random() * packBests.length)];
            const worstDog = pack.dogs[0];
            worstDog.x = randomElite.x + (Math.random() - 0.5) * 10;
            worstDog.y = randomElite.y + (Math.random() - 0.5) * 10;
          });
        }

        // Gradient refinement
        if (algoParams.useGradient) {
          const nTop = Math.max(
            1,
            Math.floor((algoParams.packSize * algoParams.gradPct) / 100)
          );
          algoPacks.forEach((pack) => {
            for (let i = 0; i < Math.min(nTop, pack.dogs.length); i++) {
              const dog = pack.dogs[i];
              const eps = 1;
              const f0 = objectiveFunction(dog.x, dog.y);
              const fx = objectiveFunction(dog.x + eps, dog.y);
              const fy = objectiveFunction(dog.x, dog.y + eps);

              const gradX = (fx - f0) / eps;
              const gradY = (fy - f0) / eps;
              const gradNorm = Math.sqrt(gradX * gradX + gradY * gradY) + 1e-12;

              dog.x += (3 * gradX) / gradNorm;
              dog.y += (3 * gradY) / gradNorm;
            }
          });
        }

        const convergence =
          algoBestFitness > -50 ? 100 : Math.max(0, 100 + algoBestFitness);
        document.getElementById("algoIteration").textContent = algoIteration;
        document.getElementById("algoBestFitness").textContent =
          algoBestFitness.toFixed(2);
        document.getElementById("algoEvals").textContent = totalEvals;
        document.getElementById("algoConvergence").textContent =
          Math.round(convergence) + "%";
      }

      function drawAlgoPacks() {
        algoCtx.fillStyle = "#f9f9f9";
        algoCtx.fillRect(0, 0, algoCanvas.width, algoCanvas.height);

        // Draw scent/fitness gradient
        const gradient = algoCtx.createRadialGradient(
          algoTarget.x,
          algoTarget.y,
          0,
          algoTarget.x,
          algoTarget.y,
          300
        );
        gradient.addColorStop(0, "rgba(255, 215, 0, 0.4)");
        gradient.addColorStop(0.5, "rgba(255, 215, 0, 0.2)");
        gradient.addColorStop(1, "rgba(255, 215, 0, 0)");
        algoCtx.fillStyle = gradient;
        algoCtx.fillRect(0, 0, algoCanvas.width, algoCanvas.height);

        // Draw target (food)
        algoCtx.fillStyle = "#e74c3c";
        algoCtx.beginPath();
        algoCtx.arc(algoTarget.x, algoTarget.y, 15, 0, Math.PI * 2);
        algoCtx.fill();
        algoCtx.font = "22px Arial";
        algoCtx.textAlign = "center";
        algoCtx.fillText("üçñ", algoTarget.x, algoTarget.y + 6);

        // üêï Different emojis for different packs
        const packEmojis = ["üê∂", "üêï", "ü¶Æ", "üê©", "üêï‚Äçü¶∫"];

        algoPacks.forEach((pack, idx) => {
          const emoji = packEmojis[idx % packEmojis.length];
          algoCtx.font = "22px Arial";
          algoCtx.textAlign = "center";
          algoCtx.textBaseline = "middle";

          pack.dogs.forEach((dog) => {
            algoCtx.fillText(emoji, dog.x, dog.y);
          });
        });

        // Highlight best position
        if (algoBestPos) {
          algoCtx.strokeStyle = "#27ae60";
          algoCtx.lineWidth = 3;
          algoCtx.beginPath();
          algoCtx.arc(algoBestPos.x, algoBestPos.y, 12, 0, Math.PI * 2);
          algoCtx.stroke();
        }
      }

      function algoAnimationLoop() {
        updateAlgoPacks();
        drawAlgoPacks();

        if (algoIteration < algoParams.maxIter) {
          algoAnimationId = setTimeout(
            () => requestAnimationFrame(algoAnimationLoop),
            50
          );
        }
      }

      function startAlgoSimulation() {
        if (algoAnimationId) clearTimeout(algoAnimationId);
        if (algoPacks.length === 0) initAlgoPacks();
        algoAnimationLoop();
      }

      function resetAlgoSimulation() {
        if (algoAnimationId) clearTimeout(algoAnimationId);
        initAlgoPacks();
        drawAlgoPacks();
        document.getElementById("algoIteration").textContent = "0";
        document.getElementById("algoBestFitness").textContent = "0.00";
        document.getElementById("algoEvals").textContent = "0";
        document.getElementById("algoConvergence").textContent = "0%";
      }

      function randomizeHyperparameters() {
        document.getElementById("nPacks").value =
          Math.floor(Math.random() * 4) + 2;
        document.getElementById("packSize").value =
          Math.floor(Math.random() * 15) + 5;
        document.getElementById("momentum").value = (
          Math.random() * 0.5 +
          0.4
        ).toFixed(1);
        document.getElementById("localAttr").value = (
          Math.random() * 0.5 +
          0.2
        ).toFixed(1);
        document.getElementById("coopWeight").value = (
          Math.random() * 0.6 +
          0.3
        ).toFixed(1);
        document.getElementById("sigma1").value = (
          Math.random() * 0.4 +
          0.2
        ).toFixed(2);
        document.getElementById("sigma2").value = (
          Math.random() * 0.2 +
          0.05
        ).toFixed(2);
        document.getElementById("zigzagProb").value = (
          Math.random() * 0.3 +
          0.1
        ).toFixed(2);
        updateAlgoParams();
        alert(
          'Hyperparameters randomized! Click "Run Optimization" to test them.'
        );
      }

      function findBestHyperparameters() {
        alert(
          "Running hyperparameter search... This will test multiple configurations."
        );

        let bestConfig = null;
        let bestScore = -Infinity;
        const trials = 10;

        for (let i = 0; i < trials; i++) {
          const config = {
            nPacks: Math.floor(Math.random() * 3) + 2,
            packSize: Math.floor(Math.random() * 10) + 6,
            momentum: Math.random() * 0.4 + 0.5,
            localAttr: Math.random() * 0.4 + 0.2,
            coopWeight: Math.random() * 0.5 + 0.4,
            sigma1: Math.random() * 0.3 + 0.25,
            sigma2: Math.random() * 0.15 + 0.08,
          };

          // Quick simulation
          const score =
            -(
              Math.abs(config.momentum - 0.6) + Math.abs(config.sigma1 - 0.35)
            ) +
            Math.random() * 0.1;

          if (score > bestScore) {
            bestScore = score;
            bestConfig = config;
          }
        }

        document.getElementById("nPacks").value = bestConfig.nPacks;
        document.getElementById("packSize").value = bestConfig.packSize;
        document.getElementById("momentum").value =
          bestConfig.momentum.toFixed(1);
        document.getElementById("localAttr").value =
          bestConfig.localAttr.toFixed(1);
        document.getElementById("coopWeight").value =
          bestConfig.coopWeight.toFixed(1);
        document.getElementById("sigma1").value = bestConfig.sigma1.toFixed(2);
        document.getElementById("sigma2").value = bestConfig.sigma2.toFixed(2);
        updateAlgoParams();

        alert(
          'Best hyperparameters found and applied! Click "Run Optimization" to see results.'
        );
      }

      // ============================================
      // SECTION 3: ROSENBROCK FUNCTION
      // ============================================

      const rosenCanvas = document.getElementById("rosenCanvas");
      const rosenCtx = rosenCanvas.getContext("2d");
      let rosenAnimationId = null;
      let rosenPacks = [];
      let rosenIteration = 0;
      let rosenBestPos = null;
      let rosenBestVal = Infinity;
      let rosenViewAngle = 45;
      let rosenViewElev = 30;

      function rosenbrock(x, y) {
        return (1 - x) * (1 - x) + 100 * (y - x * x) * (y - x * x);
      }

      function project3D(x, y, z) {
        const angleRad = (rosenViewAngle * Math.PI) / 180;
        const elevRad = (rosenViewElev * Math.PI) / 180;

        const cosA = Math.cos(angleRad);
        const sinA = Math.sin(angleRad);
        const cosE = Math.cos(elevRad);
        const sinE = Math.sin(elevRad);

        const x1 = x * cosA - y * sinA;
        const y1 = x * sinA + y * cosA;
        const z1 = z;

        const x2 = x1;
        const y2 = y1 * cosE - z1 * sinE;

        const scale = 80;
        const offsetX = rosenCanvas.width / 2;
        const offsetY = rosenCanvas.height / 2 + 100;

        return {
          x: offsetX + x2 * scale,
          y: offsetY - y2 * scale,
        };
      }

      function drawRosenbrockSurface() {
        rosenCtx.fillStyle = "#f9f9f9";
        rosenCtx.fillRect(0, 0, rosenCanvas.width, rosenCanvas.height);

        const res = 20;
        const range = 2;

        for (let i = 0; i < res; i++) {
          for (let j = 0; j < res; j++) {
            const x1 = -range + (i / res) * 2 * range;
            const y1 = -range + (j / res) * 2 * range;
            const x2 = -range + ((i + 1) / res) * 2 * range;
            const y2 = -range + ((j + 1) / res) * 2 * range;

            const z1 = Math.log(rosenbrock(x1, y1) + 1) / 5;
            const z2 = Math.log(rosenbrock(x2, y1) + 1) / 5;
            const z3 = Math.log(rosenbrock(x2, y2) + 1) / 5;
            const z4 = Math.log(rosenbrock(x1, y2) + 1) / 5;

            const p1 = project3D(x1, y1, z1);
            const p2 = project3D(x2, y1, z2);
            const p3 = project3D(x2, y2, z3);
            const p4 = project3D(x1, y2, z4);

            const avgZ = (z1 + z2 + z3 + z4) / 4;
            const colorIntensity = Math.min(255, Math.floor(avgZ * 50));
            rosenCtx.fillStyle = `rgb(${255 - colorIntensity}, ${
              100 + colorIntensity
            }, ${colorIntensity})`;
            rosenCtx.strokeStyle = "rgba(100, 100, 100, 0.3)";
            rosenCtx.lineWidth = 0.5;

            rosenCtx.beginPath();
            rosenCtx.moveTo(p1.x, p1.y);
            rosenCtx.lineTo(p2.x, p2.y);
            rosenCtx.lineTo(p3.x, p3.y);
            rosenCtx.lineTo(p4.x, p4.y);
            rosenCtx.closePath();
            rosenCtx.fill();
            rosenCtx.stroke();
          }
        }

        // Draw global minimum
        const optZ = Math.log(rosenbrock(1, 1) + 1) / 5;
        const optProj = project3D(1, 1, optZ);
        rosenCtx.fillStyle = "#27ae60";
        rosenCtx.beginPath();
        rosenCtx.arc(optProj.x, optProj.y, 8, 0, Math.PI * 2);
        rosenCtx.fill();
        rosenCtx.strokeStyle = "#229954";
        rosenCtx.lineWidth = 3;
        rosenCtx.stroke();
      }

      function initRosenPacks() {
        rosenPacks = [];
        for (let i = 0; i < algoParams.nPacks; i++) {
          const pack = { dogs: [] };
          for (let j = 0; j < algoParams.packSize; j++) {
            pack.dogs.push({
              x: (Math.random() - 0.5) * 3,
              y: (Math.random() - 0.5) * 3,
              vx: 0,
              vy: 0,
            });
          }
          rosenPacks.push(pack);
        }
        rosenIteration = 0;
        rosenBestPos = null;
        rosenBestVal = Infinity;
      }

      function updateRosenPacks() {
        rosenIteration++;
        const sigma1 =
          algoParams.sigma1 * Math.exp(-0.05 * rosenIteration) * 0.5;
        const sigma2 =
          algoParams.sigma2 * Math.exp(-0.07 * rosenIteration) * 0.5;
        const coopWeight =
          algoParams.coopWeight * (rosenIteration / algoParams.maxIter);

        let packBests = [];

        rosenPacks.forEach((pack) => {
          let packBestVal = Infinity;
          let packBestPos = null;

          pack.dogs.forEach((dog) => {
            const val = rosenbrock(dog.x, dog.y);

            if (val < packBestVal) {
              packBestVal = val;
              packBestPos = { x: dog.x, y: dog.y };
            }

            if (val < rosenBestVal) {
              rosenBestVal = val;
              rosenBestPos = { x: dog.x, y: dog.y };
            }
          });

          packBests.push(packBestPos);

          pack.dogs.forEach((dog) => {
            const dx_local = packBestPos.x - dog.x;
            const dy_local = packBestPos.y - dog.y;

            const dx_global = rosenBestPos ? rosenBestPos.x - dog.x : 0;
            const dy_global = rosenBestPos ? rosenBestPos.y - dog.y : 0;

            dog.vx =
              algoParams.momentum * dog.vx +
              algoParams.localAttr * dx_local +
              coopWeight * dx_global;
            dog.vy =
              algoParams.momentum * dog.vy +
              algoParams.localAttr * dy_local +
              coopWeight * dy_global;

            dog.x += dog.vx + sigma1 * (Math.random() - 0.5);
            dog.y += dog.vy + sigma1 * (Math.random() - 0.5);

            if (Math.random() < algoParams.zigzagProb) {
              dog.x +=
                sigma2 *
                (Math.random() - 0.5) *
                Math.sin((2 * Math.PI * rosenIteration) / algoParams.maxIter);
              dog.y +=
                sigma2 *
                (Math.random() - 0.5) *
                Math.sin((2 * Math.PI * rosenIteration) / algoParams.maxIter);
            }

            dog.x = Math.max(-2, Math.min(2, dog.x));
            dog.y = Math.max(-2, Math.min(2, dog.y));
          });
        });

        // Gradient refinement
        if (algoParams.useGradient) {
          const nTop = Math.max(
            1,
            Math.floor((algoParams.packSize * algoParams.gradPct) / 100)
          );
          rosenPacks.forEach((pack) => {
            for (let i = 0; i < Math.min(nTop, pack.dogs.length); i++) {
              const dog = pack.dogs[i];
              const eps = 0.001;
              const f0 = rosenbrock(dog.x, dog.y);
              const fx = rosenbrock(dog.x + eps, dog.y);
              const fy = rosenbrock(dog.x, dog.y + eps);

              const gradX = (fx - f0) / eps;
              const gradY = (fy - f0) / eps;
              const gradNorm = Math.sqrt(gradX * gradX + gradY * gradY) + 1e-12;

              dog.x -= (0.01 * gradX) / gradNorm;
              dog.y -= (0.01 * gradY) / gradNorm;
            }
          });
        }

        const distance = rosenBestPos
          ? Math.sqrt((rosenBestPos.x - 1) ** 2 + (rosenBestPos.y - 1) ** 2)
          : 0;
        const successRate =
          distance < 0.1 ? 100 : Math.max(0, 100 - distance * 50);

        document.getElementById("rosenBestPos").textContent = rosenBestPos
          ? `(${rosenBestPos.x.toFixed(3)}, ${rosenBestPos.y.toFixed(3)})`
          : "(0, 0)";
        document.getElementById("rosenBestVal").textContent =
          rosenBestVal.toFixed(4);
        document.getElementById("rosenDistance").textContent =
          distance.toFixed(4);
        document.getElementById("rosenSuccess").textContent =
          Math.round(successRate) + "%";
      }

      function drawRosenPacks() {
        // Draw Rosenbrock surface
        drawRosenbrockSurface();

        // üêï Different emojis for different packs
        const packEmojis = ["üê∂", "üêï", "ü¶Æ", "üê©", "üêï‚Äçü¶∫"];
        rosenCtx.font = "22px Arial";
        rosenCtx.textAlign = "center";
        rosenCtx.textBaseline = "middle";

        // Draw each pack
        rosenPacks.forEach((pack, idx) => {
          const emoji = packEmojis[idx % packEmojis.length];

          pack.dogs.forEach((dog) => {
            const z = Math.log(rosenbrock(dog.x, dog.y) + 1) / 5;
            const proj = project3D(dog.x, dog.y, z);
            rosenCtx.fillText(emoji, proj.x, proj.y);
          });
        });

        // Highlight best position
        if (rosenBestPos) {
          const z =
            Math.log(rosenbrock(rosenBestPos.x, rosenBestPos.y) + 1) / 5;
          const proj = project3D(rosenBestPos.x, rosenBestPos.y, z);

          rosenCtx.strokeStyle = "#f39c12";
          rosenCtx.lineWidth = 4;
          rosenCtx.beginPath();
          rosenCtx.arc(proj.x, proj.y, 10, 0, Math.PI * 2);
          rosenCtx.stroke();
        }
      }

      function rosenAnimationLoop() {
        updateRosenPacks();
        drawRosenPacks();

        if (rosenIteration < algoParams.maxIter) {
          rosenAnimationId = setTimeout(
            () => requestAnimationFrame(rosenAnimationLoop),
            100
          );
        }
      }

      function startRosenOptimization() {
        if (rosenAnimationId) clearTimeout(rosenAnimationId);
        if (rosenPacks.length === 0) initRosenPacks();
        rosenAnimationLoop();
      }

      function resetRosenOptimization() {
        if (rosenAnimationId) clearTimeout(rosenAnimationId);
        initRosenPacks();
        drawRosenPacks();
        document.getElementById("rosenBestPos").textContent = "(0, 0)";
        document.getElementById("rosenBestVal").textContent = "‚àû";
        document.getElementById("rosenDistance").textContent = "-";
        document.getElementById("rosenSuccess").textContent = "-";
      }

      function updateRosenView() {
        rosenViewAngle = parseInt(document.getElementById("viewAngle").value);
        rosenViewElev = parseInt(document.getElementById("viewElev").value);
        document.getElementById("viewAngleVal").textContent =
          rosenViewAngle + "¬∞";
        document.getElementById("viewElevVal").textContent =
          rosenViewElev + "¬∞";
        drawRosenPacks();
      }

      function updateRosenParams() {
        algoParams.maxIter = parseInt(document.getElementById("maxIter").value);
        document.getElementById("maxIterVal").textContent = algoParams.maxIter;
      }

      function randomizeRosenHyperparameters() {
        randomizeHyperparameters();
      }

      function findBestRosenHyperparameters() {
        alert("Auto-tuning hyperparameters for Rosenbrock function...");

        // Optimized parameters for Rosenbrock
        document.getElementById("nPacks").value = 3;
        document.getElementById("packSize").value = 12;
        document.getElementById("momentum").value = 0.7;
        document.getElementById("localAttr").value = 0.4;
        document.getElementById("coopWeight").value = 0.6;
        document.getElementById("sigma1").value = 0.25;
        document.getElementById("sigma2").value = 0.1;
        document.getElementById("gradPct").value = 20;
        document.getElementById("useGradient").checked = true;
        updateAlgoParams();

        alert(
          'Optimal hyperparameters applied! Click "Start Optimization" to see the results.'
        );
      }

      // Initialize on load
      window.onload = function () {
        resetBioSimulation();
        resetAlgoSimulation();
        resetRosenOptimization();
      };
    </script>
  </body>
</html>
